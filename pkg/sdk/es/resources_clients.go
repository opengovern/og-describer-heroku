// Code is generated by go generate. DO NOT EDIT.
package opengovernance

import (
	"context"
	heroku "github.com/opengovern/og-describer-heroku/provider/model"
	essdk "github.com/opengovern/og-util/pkg/opengovernance-es-sdk"
	steampipesdk "github.com/opengovern/og-util/pkg/steampipe"
	"github.com/turbot/steampipe-plugin-sdk/v5/plugin"
	"runtime"
)

type Client struct {
	essdk.Client
}

// ==========================  START: Account =============================

type Account struct {
	ResourceID      string                    `json:"resource_id"`
	PlatformID      string                    `json:"platform_id"`
	Description     heroku.AccountDescription `json:"Description"`
	Metadata        heroku.Metadata           `json:"metadata"`
	DescribedBy     string                    `json:"described_by"`
	ResourceType    string                    `json:"resource_type"`
	IntegrationType string                    `json:"integration_type"`
	IntegrationID   string                    `json:"integration_id"`
}

type AccountHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Account       `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type AccountHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []AccountHit      `json:"hits"`
}

type AccountSearchResponse struct {
	PitID string      `json:"pit_id"`
	Hits  AccountHits `json:"hits"`
}

type AccountPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAccountPaginator(filters []essdk.BoolFilter, limit *int64) (AccountPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "heroku_account", filters, limit)
	if err != nil {
		return AccountPaginator{}, err
	}

	p := AccountPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AccountPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AccountPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p AccountPaginator) NextPage(ctx context.Context) ([]Account, error) {
	var response AccountSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Account
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAccountFilters = map[string]string{
	"allow_tracking":            "Description.AllowTracking",
	"beta":                      "Description.Beta",
	"country_of_residence":      "Description.CountryOfResidence",
	"created_at":                "Description.CreatedAt",
	"default_organization":      "Description.DefaultOrganization",
	"default_team":              "Description.DefaultTeam",
	"delinquent_at":             "Description.DelinquentAt",
	"email":                     "Description.Email",
	"federated":                 "Description.Federated",
	"id":                        "Description.ID",
	"identity_provider":         "Description.IdentityProvider",
	"last_login":                "Description.LastLogin",
	"name":                      "Description.Name",
	"sms_number":                "Description.SMSNumber",
	"suspended_at":              "Description.SuspendedAt",
	"two_factor_authentication": "Description.TwoFactorAuthentication",
	"updated_at":                "Description.UpdatedAt",
	"verified":                  "Description.Verified",
}

func ListAccount(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAccount")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccount NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccount NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccount GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccount GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccount GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewAccountPaginator(essdk.BuildFilter(ctx, d.QueryContext, listAccountFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccount NewAccountPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListAccount paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getAccountFilters = map[string]string{
	"allow_tracking":            "Description.AllowTracking",
	"beta":                      "Description.Beta",
	"country_of_residence":      "Description.CountryOfResidence",
	"created_at":                "Description.CreatedAt",
	"default_organization":      "Description.DefaultOrganization",
	"default_team":              "Description.DefaultTeam",
	"delinquent_at":             "Description.DelinquentAt",
	"email":                     "Description.Email",
	"federated":                 "Description.Federated",
	"id":                        "Description.ID",
	"identity_provider":         "Description.IdentityProvider",
	"last_login":                "Description.LastLogin",
	"name":                      "Description.Name",
	"sms_number":                "Description.SMSNumber",
	"suspended_at":              "Description.SuspendedAt",
	"two_factor_authentication": "Description.TwoFactorAuthentication",
	"updated_at":                "Description.UpdatedAt",
	"verified":                  "Description.Verified",
}

func GetAccount(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAccount")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewAccountPaginator(essdk.BuildFilter(ctx, d.QueryContext, getAccountFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Account =============================

// ==========================  START: App =============================

type App struct {
	ResourceID      string                `json:"resource_id"`
	PlatformID      string                `json:"platform_id"`
	Description     heroku.AppDescription `json:"Description"`
	Metadata        heroku.Metadata       `json:"metadata"`
	DescribedBy     string                `json:"described_by"`
	ResourceType    string                `json:"resource_type"`
	IntegrationType string                `json:"integration_type"`
	IntegrationID   string                `json:"integration_id"`
}

type AppHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  App           `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type AppHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []AppHit          `json:"hits"`
}

type AppSearchResponse struct {
	PitID string  `json:"pit_id"`
	Hits  AppHits `json:"hits"`
}

type AppPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAppPaginator(filters []essdk.BoolFilter, limit *int64) (AppPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "heroku_app", filters, limit)
	if err != nil {
		return AppPaginator{}, err
	}

	p := AppPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AppPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AppPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p AppPaginator) NextPage(ctx context.Context) ([]App, error) {
	var response AppSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []App
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAppFilters = map[string]string{
	"acm":                     "Description.ACM",
	"archived_at":             "Description.ArchivedAt",
	"build_stack":             "Description.BuildStack",
	"buildpack_provided_desc": "Description.BuildpackProvidedDesc",
	"created_at":              "Description.CreatedAt",
	"generation":              "Description.Generation",
	"git_url":                 "Description.GitURL",
	"id":                      "Description.ID",
	"internal_routing":        "Description.InternalRouting",
	"maintenance":             "Description.Maintenance",
	"name":                    "Description.Name",
	"organization":            "Description.Organization",
	"owner":                   "Description.Owner",
	"region":                  "Description.Region",
	"released_at":             "Description.ReleasedAt",
	"repo_size":               "Description.RepoSize",
	"slug_size":               "Description.SlugSize",
	"space":                   "Description.Space",
	"stack":                   "Description.Stack",
	"team":                    "Description.Team",
	"updated_at":              "Description.UpdatedAt",
	"web_url":                 "Description.WebURL",
}

func ListApp(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListApp")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListApp NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListApp NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListApp GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListApp GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListApp GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewAppPaginator(essdk.BuildFilter(ctx, d.QueryContext, listAppFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListApp NewAppPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListApp paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getAppFilters = map[string]string{
	"acm":                     "Description.ACM",
	"archived_at":             "Description.ArchivedAt",
	"build_stack":             "Description.BuildStack",
	"buildpack_provided_desc": "Description.BuildpackProvidedDesc",
	"created_at":              "Description.CreatedAt",
	"generation":              "Description.Generation",
	"git_url":                 "Description.GitURL",
	"id":                      "Description.ID",
	"internal_routing":        "Description.InternalRouting",
	"maintenance":             "Description.Maintenance",
	"name":                    "Description.Name",
	"organization":            "Description.Organization",
	"owner":                   "Description.Owner",
	"region":                  "Description.Region",
	"released_at":             "Description.ReleasedAt",
	"repo_size":               "Description.RepoSize",
	"slug_size":               "Description.SlugSize",
	"space":                   "Description.Space",
	"stack":                   "Description.Stack",
	"team":                    "Description.Team",
	"updated_at":              "Description.UpdatedAt",
	"web_url":                 "Description.WebURL",
}

func GetApp(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetApp")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewAppPaginator(essdk.BuildFilter(ctx, d.QueryContext, getAppFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: App =============================

// ==========================  START: Build =============================

type Build struct {
	ResourceID      string                  `json:"resource_id"`
	PlatformID      string                  `json:"platform_id"`
	Description     heroku.BuildDescription `json:"Description"`
	Metadata        heroku.Metadata         `json:"metadata"`
	DescribedBy     string                  `json:"described_by"`
	ResourceType    string                  `json:"resource_type"`
	IntegrationType string                  `json:"integration_type"`
	IntegrationID   string                  `json:"integration_id"`
}

type BuildHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Build         `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type BuildHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []BuildHit        `json:"hits"`
}

type BuildSearchResponse struct {
	PitID string    `json:"pit_id"`
	Hits  BuildHits `json:"hits"`
}

type BuildPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewBuildPaginator(filters []essdk.BoolFilter, limit *int64) (BuildPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "heroku_build", filters, limit)
	if err != nil {
		return BuildPaginator{}, err
	}

	p := BuildPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p BuildPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p BuildPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p BuildPaginator) NextPage(ctx context.Context) ([]Build, error) {
	var response BuildSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Build
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listBuildFilters = map[string]string{
	"app_id":            "Description.AppID",
	"buildpacks":        "Description.Buildpacks",
	"created_at":        "Description.CreatedAt",
	"id":                "Description.ID",
	"output_stream_url": "Description.OutputStreamURL",
	"release":           "Description.Release",
	"slug":              "Description.Slug",
	"source_blob":       "Description.SourceBlob",
	"stack":             "Description.Stack",
	"status":            "Description.Status",
	"updated_at":        "Description.UpdatedAt",
	"user":              "Description.User",
}

func ListBuild(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListBuild")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListBuild NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListBuild NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListBuild GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListBuild GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListBuild GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewBuildPaginator(essdk.BuildFilter(ctx, d.QueryContext, listBuildFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListBuild NewBuildPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListBuild paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getBuildFilters = map[string]string{
	"app_id":            "Description.AppID",
	"buildpacks":        "Description.Buildpacks",
	"created_at":        "Description.CreatedAt",
	"id":                "Description.ID",
	"output_stream_url": "Description.OutputStreamURL",
	"release":           "Description.Release",
	"slug":              "Description.Slug",
	"source_blob":       "Description.SourceBlob",
	"stack":             "Description.Stack",
	"status":            "Description.Status",
	"updated_at":        "Description.UpdatedAt",
	"user":              "Description.User",
}

func GetBuild(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetBuild")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewBuildPaginator(essdk.BuildFilter(ctx, d.QueryContext, getBuildFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Build =============================

// ==========================  START: ConfigVars =============================

type ConfigVars struct {
	ResourceID      string                       `json:"resource_id"`
	PlatformID      string                       `json:"platform_id"`
	Description     heroku.ConfigVarsDescription `json:"Description"`
	Metadata        heroku.Metadata              `json:"metadata"`
	DescribedBy     string                       `json:"described_by"`
	ResourceType    string                       `json:"resource_type"`
	IntegrationType string                       `json:"integration_type"`
	IntegrationID   string                       `json:"integration_id"`
}

type ConfigVarsHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  ConfigVars    `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type ConfigVarsHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []ConfigVarsHit   `json:"hits"`
}

type ConfigVarsSearchResponse struct {
	PitID string         `json:"pit_id"`
	Hits  ConfigVarsHits `json:"hits"`
}

type ConfigVarsPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewConfigVarsPaginator(filters []essdk.BoolFilter, limit *int64) (ConfigVarsPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "heroku_configvars", filters, limit)
	if err != nil {
		return ConfigVarsPaginator{}, err
	}

	p := ConfigVarsPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ConfigVarsPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ConfigVarsPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ConfigVarsPaginator) NextPage(ctx context.Context) ([]ConfigVars, error) {
	var response ConfigVarsSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ConfigVars
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listConfigVarsFilters = map[string]string{
	"app_name":  "Description.AppName",
	"variables": "Description.Variables",
}

func ListConfigVars(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListConfigVars")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListConfigVars NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListConfigVars NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListConfigVars GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListConfigVars GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListConfigVars GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewConfigVarsPaginator(essdk.BuildFilter(ctx, d.QueryContext, listConfigVarsFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListConfigVars NewConfigVarsPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListConfigVars paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getConfigVarsFilters = map[string]string{
	"app_name":  "Description.AppName",
	"variables": "Description.Variables",
}

func GetConfigVars(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetConfigVars")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewConfigVarsPaginator(essdk.BuildFilter(ctx, d.QueryContext, getConfigVarsFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ConfigVars =============================

// ==========================  START: Domain =============================

type Domain struct {
	ResourceID      string                   `json:"resource_id"`
	PlatformID      string                   `json:"platform_id"`
	Description     heroku.DomainDescription `json:"Description"`
	Metadata        heroku.Metadata          `json:"metadata"`
	DescribedBy     string                   `json:"described_by"`
	ResourceType    string                   `json:"resource_type"`
	IntegrationType string                   `json:"integration_type"`
	IntegrationID   string                   `json:"integration_id"`
}

type DomainHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Domain        `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type DomainHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []DomainHit       `json:"hits"`
}

type DomainSearchResponse struct {
	PitID string     `json:"pit_id"`
	Hits  DomainHits `json:"hits"`
}

type DomainPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDomainPaginator(filters []essdk.BoolFilter, limit *int64) (DomainPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "heroku_domain", filters, limit)
	if err != nil {
		return DomainPaginator{}, err
	}

	p := DomainPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DomainPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DomainPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p DomainPaginator) NextPage(ctx context.Context) ([]Domain, error) {
	var response DomainSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Domain
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDomainFilters = map[string]string{
	"acm_status":        "Description.ACMStatus",
	"acm_status_reason": "Description.ACMStatusReason",
	"app_id":            "Description.AppID",
	"app_name":          "Description.AppName",
	"cname":             "Description.CName",
	"created_at":        "Description.CreatedAt",
	"hostname":          "Description.Hostname",
	"id":                "Description.ID",
	"kind":              "Description.Kind",
	"sni_endpoint":      "Description.SNIEndpoint",
	"status":            "Description.Status",
	"updated_at":        "Description.UpdatedAt",
}

func ListDomain(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDomain")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListDomain NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListDomain NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListDomain GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListDomain GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListDomain GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewDomainPaginator(essdk.BuildFilter(ctx, d.QueryContext, listDomainFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListDomain NewDomainPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListDomain paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getDomainFilters = map[string]string{
	"acm_status":        "Description.ACMStatus",
	"acm_status_reason": "Description.ACMStatusReason",
	"app_id":            "Description.AppID",
	"app_name":          "Description.AppName",
	"cname":             "Description.CName",
	"created_at":        "Description.CreatedAt",
	"hostname":          "Description.Hostname",
	"id":                "Description.ID",
	"kind":              "Description.Kind",
	"sni_endpoint":      "Description.SNIEndpoint",
	"status":            "Description.Status",
	"updated_at":        "Description.UpdatedAt",
}

func GetDomain(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDomain")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewDomainPaginator(essdk.BuildFilter(ctx, d.QueryContext, getDomainFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Domain =============================

// ==========================  START: Dyno =============================

type Dyno struct {
	ResourceID      string                 `json:"resource_id"`
	PlatformID      string                 `json:"platform_id"`
	Description     heroku.DynoDescription `json:"Description"`
	Metadata        heroku.Metadata        `json:"metadata"`
	DescribedBy     string                 `json:"described_by"`
	ResourceType    string                 `json:"resource_type"`
	IntegrationType string                 `json:"integration_type"`
	IntegrationID   string                 `json:"integration_id"`
}

type DynoHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Dyno          `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type DynoHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []DynoHit         `json:"hits"`
}

type DynoSearchResponse struct {
	PitID string   `json:"pit_id"`
	Hits  DynoHits `json:"hits"`
}

type DynoPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDynoPaginator(filters []essdk.BoolFilter, limit *int64) (DynoPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "heroku_dyno", filters, limit)
	if err != nil {
		return DynoPaginator{}, err
	}

	p := DynoPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DynoPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DynoPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p DynoPaginator) NextPage(ctx context.Context) ([]Dyno, error) {
	var response DynoSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Dyno
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDynoFilters = map[string]string{
	"app_id":     "Description.AppID",
	"app_name":   "Description.AppName",
	"attach_url": "Description.AttachURL",
	"command":    "Description.Command",
	"created_at": "Description.CreatedAt",
	"id":         "Description.ID",
	"name":       "Description.Name",
	"release":    "Description.Release",
	"size":       "Description.Size",
	"state":      "Description.State",
	"type":       "Description.Type",
	"updated_at": "Description.UpdatedAt",
}

func ListDyno(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDyno")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListDyno NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListDyno NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListDyno GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListDyno GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListDyno GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewDynoPaginator(essdk.BuildFilter(ctx, d.QueryContext, listDynoFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListDyno NewDynoPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListDyno paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getDynoFilters = map[string]string{
	"app_id":     "Description.AppID",
	"app_name":   "Description.AppName",
	"attach_url": "Description.AttachURL",
	"command":    "Description.Command",
	"created_at": "Description.CreatedAt",
	"id":         "Description.ID",
	"name":       "Description.Name",
	"release":    "Description.Release",
	"size":       "Description.Size",
	"state":      "Description.State",
	"type":       "Description.Type",
	"updated_at": "Description.UpdatedAt",
}

func GetDyno(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDyno")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewDynoPaginator(essdk.BuildFilter(ctx, d.QueryContext, getDynoFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Dyno =============================

// ==========================  START: DynoSize =============================

type DynoSize struct {
	ResourceID      string                     `json:"resource_id"`
	PlatformID      string                     `json:"platform_id"`
	Description     heroku.DynoSizeDescription `json:"Description"`
	Metadata        heroku.Metadata            `json:"metadata"`
	DescribedBy     string                     `json:"described_by"`
	ResourceType    string                     `json:"resource_type"`
	IntegrationType string                     `json:"integration_type"`
	IntegrationID   string                     `json:"integration_id"`
}

type DynoSizeHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  DynoSize      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type DynoSizeHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []DynoSizeHit     `json:"hits"`
}

type DynoSizeSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  DynoSizeHits `json:"hits"`
}

type DynoSizePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDynoSizePaginator(filters []essdk.BoolFilter, limit *int64) (DynoSizePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "heroku_dyno_size", filters, limit)
	if err != nil {
		return DynoSizePaginator{}, err
	}

	p := DynoSizePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DynoSizePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DynoSizePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p DynoSizePaginator) NextPage(ctx context.Context) ([]DynoSize, error) {
	var response DynoSizeSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DynoSize
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDynoSizeFilters = map[string]string{
	"architecture":       "Description.Architecture",
	"compute":            "Description.Compute",
	"cost":               "Description.Cost",
	"dedicated":          "Description.Dedicated",
	"generation":         "Description.Generation",
	"id":                 "Description.ID",
	"memory":             "Description.Memory",
	"name":               "Description.Name",
	"precise_dyno_units": "Description.PreciseDynoUnits",
	"private_space_only": "Description.PrivateSpaceOnly",
}

func ListDynoSize(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDynoSize")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListDynoSize NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListDynoSize NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListDynoSize GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListDynoSize GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListDynoSize GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewDynoSizePaginator(essdk.BuildFilter(ctx, d.QueryContext, listDynoSizeFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListDynoSize NewDynoSizePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListDynoSize paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getDynoSizeFilters = map[string]string{
	"architecture":       "Description.Architecture",
	"compute":            "Description.Compute",
	"cost":               "Description.Cost",
	"dedicated":          "Description.Dedicated",
	"generation":         "Description.Generation",
	"id":                 "Description.ID",
	"memory":             "Description.Memory",
	"name":               "Description.Name",
	"precise_dyno_units": "Description.PreciseDynoUnits",
	"private_space_only": "Description.PrivateSpaceOnly",
}

func GetDynoSize(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDynoSize")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewDynoSizePaginator(essdk.BuildFilter(ctx, d.QueryContext, getDynoSizeFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: DynoSize =============================
